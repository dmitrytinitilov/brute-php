# Хранение, удаление и клонирование объектов


Рассмотрим работу с обычными переменными
```php
$a = 5;
$b=$a;
$b=7;
echo $a;// выведется 5
```

Результат не является удивительным. $a и $b хранятся в разных ячейках памяти. Поэтому изменение переменной $b, никак не влияет на переменную $a.


Теперь создадим объект от класса Num

```php
class Num {

	public $x;

}

$obj = new Num();

$obj->x = 5;

$obj2 = $obj;

$obj2->x = 7;

echo $obj->x; //выведет 7 !!!
```


Причина в следующем – в переменных хранится не сам объект, а лишь ссылка на него. Когда мы делаем присвоение $obj2=$obj , в $obj2 копируется лишь ссылка, а не сам объект. То есть две переменные указывают на один и тот же объект.

Сначала мы устанавливаем $x=5 через $obj, а затем меняем его на 7 через $obj2



**Удаление объектов**

Удаление объектов происходит по завершению программы, либо если все ссылки объекты потеряны. Освобождением памяти из под объекта занимается сборщик мусора.

Для того, чтобы удалить принудительно объект, нужно удалить все ссылки на него через функцию unset

```php
unset($obj);
```

**Деструкторы**

Деструктор вызывается при удаление объекта сборщиком мусора. Мы можем модифицировать поведение класса при удалении, используя метод

```php
function __destruct() {

	echo “I’ll be back”;

}
```

**Клонирование объектов**

Если мы хотим создать копию объекта, то нам необходимо использовать конструкцию clone

```php
class Box {
	public $x;
}

$a = new Box();
$a->x = 5;

$b = clone $a;

$b->x = 7;
echo $a->x; //5 , потому что в $b теперь хранится другой объект со своим $x
echo $b->x; //7
```

**Метод __clone**

Если нам нужна измененная копия исходного объекта, то мы можем добавить метод __clone внутрь объекта. Этот метод будет вызываться для нового объекта сразу после клонирования

```php
function __clone() {
		$this->x = mt_rand(0,100);
}
```

То есть при клонировании свойство $x будет меняться на произвольное число

**Практика**
1.	Сделать так, чтобы объект удалялся до и после надписи THE END
2.	Клонируем объект div так, чтобы он не менял яркость, но менял оттенок
3. Сделать внешнюю функцию, которая делает прямоугольник серым. Добиться, чтобы при ее работе не менялся исходный прямоугольник

